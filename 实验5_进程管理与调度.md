# 实验五：进程管理与调度

## 一、实验目的

本实验对应指导手册“实验5：进程管理与调度”，在前面完成启动、内存管理、Trap/时钟中断等基础上，进一步完成内核中最核心的一组抽象：**进程（process）** 与 **调度（scheduler）**。实验目标包括：

1. 理解 `struct proc` 的关键字段与生命周期：状态机、内核栈、页表、trapframe、父子关系、文件表等。
2. 实现并验证进程创建/退出/等待的完整路径：`fork → exit → wait`，以及资源回收的时机与策略。
3. 实现上下文切换机制（`swtch.S`），理解“为什么只保存被调用者保存寄存器就足够”以及栈切换的本质。
4. 实现一个可运行的调度器：本实验采用 **多级反馈队列 MLFQ + 老化提升（aging）**，并与时钟滴答 `ticks` 联动，形成时间片轮转与动态优先级。
5. 实现进程同步原语：信号量 `semaphore` 与睡眠锁 `sleeplock`，理解它们如何基于 `sleep/wakeup` 构建，避免忙等待。

---

## 二、实验原理

### 2.1 进程抽象：PCB + 资源集合 + 状态机

操作系统中的进程通常由 **进程控制块（PCB）** 表示。PCB 记录进程运行所需的一切信息（寄存器现场、内核栈、地址空间、打开文件、当前目录等）。本实验中 PCB 为 `struct proc`，进程状态机典型如下（与 xv6 类似）：

```
UNUSED → USED → RUNNABLE → RUNNING → SLEEPING → ZOMBIE → UNUSED
```

- `RUNNABLE`：可被调度运行
- `RUNNING`：正在 CPU 上运行
- `SLEEPING`：因等待某事件而睡眠（阻塞）
- `ZOMBIE`：已退出但尚未被父进程 `wait()` 回收（保留退出码等信息）

### 2.2 fork/exit/wait：父子协作完成生命周期闭环

- `fork()`：复制父进程资源（至少复制页表/用户内存、文件引用、trapframe），为子进程分配 PID，并把其置为 `RUNNABLE`。
- `exit(status)`：释放自身大部分资源，设置退出码，唤醒父进程等待者，并进入 `ZOMBIE`。
- `wait(&status)`：父进程扫描子进程表；若发现 `ZOMBIE` 子进程，则回收其 PCB/内核资源并返回其 pid；若无可回收子进程则睡眠等待。

这套协作保证了：**子进程退出后不会立刻消失（避免父进程来不及读取退出码）**，同时也不会永久占用资源（父进程最终负责回收）。

### 2.3 上下文切换：保存/恢复“被调用者保存寄存器”即可

RISC-V ABI 约定中：

- `a0-a7, t0-t6` 属于 caller-saved（调用者保存）
- `s0-s11` 属于 callee-saved（被调用者保存）

`swtch(old, new)` 本质是在“内核态”进行切换：它将当前内核执行流的关键寄存器（`ra/sp/s0-s11`）保存到 `old->context`，再从 `new->context` 恢复这些寄存器，最后 `ret` 跳转到新上下文继续执行。  
由于切换点通常发生在 C 函数调用边界，保存 callee-saved 就足以保证切换后能正确“续跑”。

### 2.4 调度：MLFQ 的核心思想（动态优先级 + 反馈）

多级反馈队列（MLFQ）设计目标是同时兼顾：

- **交互型任务**：短 CPU burst，应该更快得到响应（更高优先级）
- **CPU 密集型任务**：长时间占用 CPU，会被逐级降低优先级（更长时间片、但更低调度优先级）

本实验的关键机制包括：

1. 多个队列（level 0~4），越低 level 表示越高优先级；
2. 各级对应不同时间片长度（如 `{1,2,4,8,16}` 个 ticks）；
3. 进程用完本级时间片仍未阻塞/让出，则降级；
4. **老化（aging）**：长期得不到运行的低优先级进程会被提升，防止饥饿。

### 2.5 sleep/wakeup：阻塞同步的基础

`sleep(chan, lk)` 做两件事：

1. 把当前进程的 `chan` 设置为等待对象，状态置为 `SLEEPING`；
2. 原子地释放 `lk` 并让出 CPU（进入调度器），避免“睡眠-唤醒丢失”。

`wakeup(chan)` 遍历进程表，将所有 `p->chan == chan` 的进程从 `SLEEPING` 置为 `RUNNABLE` 并重新入队。

信号量、睡眠锁等高级同步原语，正是以 `sleep/wakeup` 为原子阻塞机制构建出来的。

---

## 三、实验内容与实现（结合源码分析）

本实验关键源码文件：

- `proc.c`：进程创建/退出/等待、调度器（MLFQ）、sleep/wakeup 等
- `swtch.S`：上下文切换汇编实现
- `semaphore.c`：基于 sleep/wakeup 的信号量
- `sleeplock.c`：睡眠锁（避免忙等待）

### 3.1 proc.c：进程表、PID 与初始化

#### (1) 进程表与全局变量

`proc.c` 采用数组实现进程表：

```c
struct proc proc[NPROC];
struct proc *initproc;
int nextpid = 1;

extern volatile uint64 ticks;
struct spinlock wait_lock;
```

- 数组的优点是简单、定位快；缺点是上限固定（`NPROC`）。
- `nextpid` 提供 PID 分配基础（必须配合锁/关中断确保并发安全）。
- `ticks` 由时钟中断更新，是调度时间片与 aging 的“时间基准”。

#### (2) MLFQ 参数与队列结构

```c
#define MLFQ_LEVELS 5
static const int mlfq_time_slices[MLFQ_LEVELS] = {1, 2, 4, 8, 16};
#define MLFQ_AGING_TICKS 50

static struct proc *mlfq_head[MLFQ_LEVELS];
static struct proc *mlfq_tail[MLFQ_LEVELS];
```

- `mlfq_head/tail` 构成每级队列的链表头尾指针；
- “单核 + 关中断保护”是常见简化：避免在队列操作中引入复杂的并发锁。

#### (3) procinit：初始化 PCB 与队列

`procinit()` 对每个 PCB 做字段初始化（state、kstack、pagetable、trapframe、ofile[] 等），并初始化 MLFQ 队列结构。这保证后续 `alloc/free` 操作的前置条件成立。

---

### 3.2 proc.c：进程创建 fork 与资源复制要点

`fork()` 的典型流程（与 xv6 思路一致）：

1. 找到一个 `UNUSED` 的 PCB 槽位，分配 PID、内核栈、trapframe、页表等；
2. 复制父进程地址空间（或采用 COW 优化的共享复制）；
3. 复制打开文件引用、当前目录引用；
4. 设置子进程 trapframe，使其从 `fork` 返回值为 0；
5. 将子进程置为 `RUNNABLE` 并入队（MLFQ 队列）。

代码中可见对 `trapframe` 与 `context` 的处理：`context.ra` 指向 `forkret`，使新进程第一次被调度运行时能从内核正确返回到用户态（或执行初始化路径）。

> 报告建议：在测试中打印父子进程 fork 返回值，验证“父返回子 pid，子返回 0”。

---

### 3.3 proc.c：exit/wait 与 ZOMBIE 的必要性

#### (1) 为什么需要 ZOMBIE？

子进程退出时，父进程可能还没来得及 `wait()` 获取退出码或回收资源。若子进程立即释放 PCB，父进程将无法得知子进程的退出信息；同时 pid 可能被重用，引发逻辑混乱。  
因此 `exit()` 将进程状态置为 `ZOMBIE`，仅保留必要信息（退出码、pid、少量统计），等待父进程 `wait()` 回收。

#### (2) wait 的阻塞逻辑

`wait()` 需要在“没有可回收子进程”时阻塞睡眠，直到 `exit()` 唤醒父进程。该过程必须用锁（例如 `wait_lock`）保护，避免出现以下竞态：

- 父进程判断“没有 ZOMBIE 子进程”准备睡眠；
- 子进程恰好 exit 并 wakeup；
- 父进程随后睡眠导致“唤醒丢失”，从而永久等待。

正确实现的关键是：**检查条件与进入睡眠必须在同一锁保护下原子进行**。

---

### 3.4 swtch.S：上下文切换的寄存器集合与栈切换

`swtch.S` 的核心（节选）：

```asm
# 保存
sd ra, 0(a0)
sd sp, 8(a0)
sd s0, 16(a0)
...
sd s11, 104(a0)

# 恢复
ld ra, 0(a1)
ld sp, 8(a1)
ld s0, 16(a1)
...
ld s11, 104(a1)

ret
```

解释要点：

- `a0` 指向 old context，`a1` 指向 new context；
- 保存 `ra/sp` 与 `s0-s11`，就能保证在返回时“回到正确的 C 调用点”，同时切换到新进程的内核栈；
- `ret` 会跳转到恢复后的 `ra`，因此新上下文的 `ra` 必须在创建进程时被正确初始化（例如指向 `forkret` 或 `scheduler` 的返回点）。

---

### 3.5 proc.c：调度器（MLFQ + aging）实现要点

#### (1) 入队/出队与 pick_next

`mlfq_enqueue(_locked)` 把 `RUNNABLE` 进程挂到对应 level 的队尾；  
`mlfq_pick_next()` 从 level 0 到 level 4 依次查找，取出第一个就绪进程（高优先级先运行）。

这种策略直接体现“优先级队列”思想：越高优先级越先被调度。

#### (2) 时间片与降级

每个进程在 PCB 中维护：

- `priority_level`：当前所在队列级别
- `ticks_in_level`：已消耗的 ticks 数

当进程在本级消耗 ticks 达到 `mlfq_time_slices[level]`，且仍保持 `RUNNABLE/RUNNING`（未因 I/O 阻塞），则：

- `priority_level++`（降级，最低到 level 4）
- `ticks_in_level = 0`
- 重新入队

这使 CPU 密集型任务逐渐“下沉”，把 CPU 留给更短小的交互型任务。

#### (3) 老化提升（aging）

`MLFQ_AGING_TICKS` 用于防止饥饿：如果一个低优先级任务长期得不到运行（等待 ticks 太久），则提升其优先级（level 下降）。  
这保证了公平性：即使系统中不断涌入高优先级短任务，低优先级任务最终也能获得运行机会。

---

### 3.6 sleep/wakeup：阻塞同步的正确性要点

`semaphore.c` 使用了经典 P/V 操作模型：

```c
void sem_wait(struct semaphore *sem)
{
  acquire(&sem->lock);
  while (sem->value == 0) {
    sleep(sem, &sem->lock);
  }
  sem->value--;
  release(&sem->lock);
}

void sem_signal(struct semaphore *sem)
{
  acquire(&sem->lock);
  sem->value++;
  wakeup(sem);
  release(&sem->lock);
}
```

关键点：

- **while 而不是 if**：防止伪唤醒或多个等待者竞争导致 value 再次为 0；
- `sleep(sem, &sem->lock)` 必须原子释放锁并睡眠，避免丢失唤醒；
- `wakeup(sem)` 以 `chan=sem` 唤醒所有等待该信号量的进程。

`sleeplock.c`（睡眠锁）思想与信号量类似：用自旋锁保护锁元数据；如果锁忙，则 sleep，等待释放方 wakeup，避免纯自旋造成 CPU 浪费。该锁适用于可能长时间持有的临界区（例如磁盘 I/O）。

---

## 四、实验步骤

1. 阅读手册实验5，明确要实现的模块：进程状态机、fork/exit/wait、上下文切换、调度器与同步原语。
2. 阅读 `proc.c`：先理解 `struct proc` 字段与状态转换，再看进程创建/销毁路径，最后看调度器与 sleep/wakeup。
3. 阅读 `swtch.S`：确认保存/恢复寄存器集合与 context 结构布局一致。
4. 阅读 `semaphore.c` 与 `sleeplock.c`：理解它们如何复用 `sleep/wakeup` 构建阻塞同步。
5. 编译运行，按测试用例观察：
   - 进程创建数量、pid 分配是否正确
   - 调度是否周期性切换（ticks 增长且进程轮转/优先级变化）
   - 信号量/睡眠锁是否能正确阻塞与唤醒

---

## 五、实验结果与测试

make qemu之后自动运行测试函数，输出结果

![](./实验五截图1.png)
![](./实验五截图2.png)
![](./实验五截图3.png)
![](./实验五截图4.png)
---

## 六、实验分析与问题讨论

1. **为什么需要锁保护？**  
   进程表、PID 分配、父子关系、等待队列等都是共享数据结构。没有锁会产生竞态：重复分配 PID、丢失唤醒、同一 PCB 被重复回收等。关中断只解决“单核抢占”问题，但不等价于所有并发安全（未来多核必须用锁）。
2. **ZOMBIE 的意义**  
   ZOMBIE 是“退出信息的缓冲区”，保证父进程能可靠获取子进程退出码并回收资源，避免 PID 重用带来的混乱。
3. **MLFQ 的权衡**  
   MLFQ 对交互型任务友好，但参数敏感（队列级数、时间片、aging 阈值）。参数过小会导致频繁切换；过大可能导致交互响应差。工程上通常需要统计与调优。
4. **sleep/wakeup 的正确性边界**  
   正确的关键是“检查条件 + 入睡”必须原子完成；因此 `sleep(chan, lk)` 的锁语义至关重要。信号量与睡眠锁的 while 循环可防止伪唤醒与竞争问题。
5. **上下文切换开销**  
   保存/恢复 `ra/sp/s0-s11` 属于固定成本，切换过于频繁会损失吞吐。调度器需要在公平性与效率之间做平衡。

---

## 七、实验总结与心得体会

本实验把内核从“能跑”推进到“能并发”：通过 `proc.c` 完成进程生命周期闭环与 MLFQ 调度，通过 `swtch.S` 打通上下文切换底座，并用信号量与睡眠锁建立了阻塞同步原语。尤其是 MLFQ + aging 的实现，让我从工程角度理解了调度算法需要解决的三个矛盾：响应性、公平性与吞吐量。该实验也为下一步系统调用/用户态进程运行/文件系统并发访问提供了必需的调试与运行基础。
