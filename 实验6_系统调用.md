# 实验六：系统调用

## 一、实验目的

本实验对应指导手册“实验6：系统调用”。目标是在已有的“用户态/内核态切换（trampoline）”与“Trap/时钟中断”基础上，建立一套**完整、可扩展且安全的系统调用框架**。通过本实验应达到：

1. 理解系统调用的端到端链路：用户函数 → `usys.S` 桩代码 → `ecall` → `trampoline.S:uservec` → `usertrap` → `syscall()` 分发 → `sys_xxx` 实现 → 返回用户态。
2. 掌握系统调用参数传递与返回值约定：参数经 `a0~a5` 传入，系统调用号经 `a7` 传入，返回值写回 `a0`。
3. 实现系统调用分发表与参数解析/用户指针校验机制（防止内核直接解引用用户指针导致崩溃/越权）。
4. 结合进程与文件系统模块，实现并验证一组常用系统调用（进程类、文件类、内存类、时间类等）。

---

## 二、实验原理

### 2.1 系统调用与 Trap：为什么需要 `ecall`

用户程序运行在 U 模式，无法直接访问内核数据结构与特权指令。系统调用通过 `ecall` 触发一次 Trap，CPU 跳转到特权态入口（本实验为 trampoline 的 `uservec`），由内核接管并在完成服务后返回用户态。  
系统调用本质是“受控的特权提升”，其核心价值在于：

- **隔离**：用户态不能任意读写内核内存
- **抽象**：把底层硬件/内核实现封装为稳定接口
- **安全**：内核统一校验参数与权限

### 2.2 参数与返回值约定（RISC-V）

本项目约定与 xv6 风格一致：

- `a7`：系统调用编号（SYS_xxx）
- `a0~a5`：最多 6 个整型/指针参数
- 返回值：内核将结果写回 `trapframe->a0`，用户态在 `ecall` 返回后从 `a0` 读取

因此，系统调用分发层只要能读取 `trapframe` 中的寄存器，就能得到系统调用号与参数。

### 2.3 为什么不能直接访问用户指针：`copyin/copyout` 与指针校验

用户传入的指针是**用户虚拟地址**，可能存在以下风险：

- 指向未映射页面 → 内核访问会触发页故障甚至 panic
- 指向内核地址空间 → 越权读写（严重漏洞）
- 指向只读页面但要求写 → 违反权限

因此内核必须：

1. 校验用户地址范围（是否落在用户空间、是否映射、是否具备 PTE_U 等权限）
2. 对“从用户读数据/向用户写数据”使用 `copyin/copyout`（在用户页表上进行安全访问）

本实验在 `syscall.c` 中实现了系统调用层面的用户指针校验辅助函数，并结合 `copyin/copyout` 完成参数拷贝。

---

## 三、实验内容与实现（结合源码分析）

> 本节以你提供的源代码为准：`syscall.c / sysproc.c / sysfile.c / trampoline.S / usys.S`。

### 3.1 用户态桩代码：`usys.S` 如何发起系统调用

`usys.S` 由脚本生成（文件头已有注释），每个系统调用对应一个 `__sys_xxx` 汇编桩，统一模式如下：

```asm
.global __sys_getpid
__sys_getpid:
    li a7, SYS_getpid   # 系统调用号
    ecall               # 触发陷入
    ret                 # 返回用户态，a0 中已有返回值
```

要点：

- 用户态只负责“把编号放到 a7”并执行 `ecall`；
- 参数由调用者按 ABI 放在 `a0~a5`，桩代码不需要额外搬运；
- `ret` 返回到用户函数，结果仍在 `a0`。

这种“极薄桩”是系统调用的常见实现：简单、稳定、易扩展（新增 syscall 只需加一个桩并分配编号）。

---

### 3.2 trampoline：`trampoline.S` 的 uservec/userret（用户态 ↔ 内核态切换）

`trampoline.S` 是系统调用链路中**最关键**的一段：它运行在一个被 **内核页表与每个用户页表同时映射到同一虚拟地址（TRAMPOLINE）** 的页面上，因此能在切换页表的过程中持续执行，解决“切换页表后代码在哪里”的问题。

#### (1) `uservec`：用户态陷入时保存寄存器并切换到内核页表

文件中清晰描述了流程（节选要点）：

- 先把 `a0` 换成 `TRAPFRAME` 的固定映射地址；
- 把所有用户寄存器保存到 trapframe（包括保存用户 `a0` 与 `sepc`）；
- 从 trapframe 取出内核上下文信息（内核栈、hartid、usertrap 入口、内核 satp）；
- 执行 `csrw satp, t1` 切换到内核页表并 `sfence.vma`；
- `jalr t0` 跳转进入 C 语言 `usertrap()`。

这段逻辑决定了：系统调用进入内核后，C 代码看到的寄存器现场都已规整地放在 trapframe 中。

#### (2) `userret`：返回用户态时恢复寄存器并 `sret`

`userret` 接收 `a0` 作为“用户页表根（satp）”，做三件事：

1. 切换回用户页表并刷新 TLB；
2. 从 TRAPFRAME 恢复所有用户寄存器；
3. 将 `trapframe->epc` 写回 `sepc`，最后 `sret` 回到用户态继续执行。

这个对称结构保证：**用户态寄存器像被“冻结-解冻”一样**，系统调用返回点精确回到 `ecall` 之后。

---

### 3.3 系统调用分发核心：`syscall.c`

`syscall.c` 的职责在文件头注释中写得很明确：**系统调用表、参数解析、用户指针验证、按 a7 分发**。

#### (1) 系统调用表：编号 → 实现函数

代码中定义了 `struct syscall_desc`，包含：

- `func`：内核实现入口 `uint64 (*)(void)`
- `name`：调试名称
- `arg_count`：参数数量（位于 a0~a5）

并用 `syscall_table[]` 进行初始化：

```c
struct syscall_desc syscall_table[] = {
  [SYS_exit]   = { sys_exit,   "exit",   1 },
  [SYS_getpid] = { sys_getpid, "getpid", 0 },
  [SYS_fork]   = { sys_fork,   "fork",   0 },
  ...
  [SYS_klog_set_threshold] = { sys_klog_set_threshold, "klog_set_threshold", 2 },
  [SYS_sleep] = { sys_sleep, "sleep", 1 },
};
```

优点：

- **扩展性强**：新增系统调用只需新增 `SYS_xxx` 编号、实现 `sys_xxx()` 并填入表项
- **可调试**：保存 name 后，未知 syscall 可打印 `pid/name/num`

#### (2) 从 trapframe 取参数：`get_syscall_arg` 与 `argint/argaddr/argstr`

`get_syscall_arg(n, &arg)` 直接从当前进程 `p->trapframe->a0~a5` 读取第 n 个参数。这种实现对应实验约定“最多 6 个参数”。

上层封装：

- `argint(n, &x)`：取第 n 个参数并转 int
- `argaddr(n, &addr)`：取第 n 个参数当作地址（指针）
- `argstr(n, buf, max)`：取第 n 个参数为字符串地址，并通过 `fetchstr/copyin` 安全拷贝到内核缓冲

这组接口让每个 `sys_xxx` 都能用一致方式解析参数，避免在每个 syscall 实现里重复写寄存器读取与校验逻辑。

#### (3) 用户指针范围校验：`check_user_range / check_user_ptr_rw`

`check_user_range(addr, size, write)` 会逐页检查用户指针覆盖范围：

- 地址不得超过 `MAXVA`；
- 页面必须存在且带 `PTE_U`；
- 如果 `write=1`（内核要向用户写），还要检查写权限；

并提供便捷封装：

- `check_user_ptr(ptr, size)`：只读校验
- `check_user_ptr_rw(ptr, size, write)`：可指定读写

这个设计很重要：它让系统调用可以在进入文件系统/进程子系统之前就把“危险指针”挡在 syscall 层，从而避免把错误扩散到更深层。

#### (4) 分发入口：`syscall_dispatch()`

分发逻辑：

1. 读取 `num = p->trapframe->a7`；
2. 检查范围与表项是否存在；
3. 调用 `syscall_table[num].func()`；
4. 把返回值写入 `p->trapframe->a0`。

对于未知 syscall，直接打印并返回 -1。该策略对调试非常友好。

---

### 3.4 进程类系统调用：`sysproc.c`

`sysproc.c` 实现了典型进程相关 syscall，并与实验五的进程管理/调度模块直接对接。

#### (1) `sys_sleep`：基于 ticks 的可中断睡眠

核心逻辑（概念层面）：

- 获取睡眠 ticks 数；
- 记录起始 ticks；
- 在 `tickslock` 保护下循环：若未达到目标 ticks，则 `sleep(&ticks, &tickslock)` 阻塞等待下一次 tick；若进程被 kill 则返回 -1。

这体现了“系统调用 + sleep/wakeup”的经典组合：**用户态请求 sleep，内核用阻塞而非忙等实现**。

#### (2) `sys_sbrk`：调整用户堆大小

`sys_sbrk(n)` 返回旧的堆顶地址，并根据 n 的正负扩大或缩小地址空间。实现策略通常是：

- `n > 0`：扩展用户空间，分配新页并清零
- `n < 0`：回收多余页面（但不能小于 0）

该 syscall 是后续 `malloc` 等用户态内存分配器的基础。

#### (3) `sys_getpriority`：与 MLFQ 调度器联动

该 syscall 返回 `p->priority_level`，可用于在用户态观察调度器的动态行为（验证“CPU 密集任务优先级下沉/aging 提升”等现象）。

#### (4) `sys_klog_set_threshold`：内核日志策略控制

实现对参数范围进行校验（error~debug），并调用 `klog_set_threshold()` 设置记录与控制台输出级别。  
这属于“系统调用扩展能力”的示例：让用户态以受控方式影响内核行为。

---

### 3.5 文件类系统调用：`sysfile.c`

`sysfile.c` 实现了 `open/read/write/close/unlink/symlink/...` 等文件系统接口，并能看到“事务 begin/end”与 inode 层操作（与实验7文件系统会强耦合）。

#### (1) `sys_open`：支持 O_CREATE、普通打开与特殊设备路径

代码对 `path` 与 `omode` 做参数解析，然后分三类处理：

1. 特殊路径 `"console"` 或 `"/dev/console"`：直接映射到控制台设备，绕开 inode 流程；
2. `O_CREATE`：调用 `create()` 分配 inode 并建立目录项；
3. 普通打开：`namei` 找到 inode，根据类型（文件/目录/设备）与权限检查决定是否允许打开。

此外对设备文件还会校验 `major` 与驱动读写回调是否存在，避免用户打开一个“没有驱动能力的设备号”。

#### (2) `sys_read/sys_write`：fd + 用户缓冲区 + 长度

`sys_read/sys_write` 解析：

- 文件描述符 fd
- 用户缓冲区地址（用户指针）
- 长度 n

随后交给 `fileread/filewrite`。注意：缓冲区是用户地址，因此必须通过参数解析与安全拷贝机制避免内核直接访问用户指针。

#### (3) `sys_unlink`：目录项删除与链接计数维护

该实现属于 inode/目录操作的典型路径：

- 对父目录与目标 inode 上锁；
- 检查不能 unlink `.` 或 `..`；
- 从目录中删除目录项；
- 对 inode `nlink--` 并更新；

并包裹在 `begin_transaction/end_transaction` 之间，说明该文件系统具备日志/事务语义（与实验7的日志文件系统一致）。

#### (4) `sys_symlink` 与 `sys_chdir`

`sys_symlink(target, linkpath)` 创建符号链接 inode 并将 target 字符串写入 inode 数据区（可以看到 `strlen(target)+1` 保存结尾 `\0` 的细节）。  
`sys_chdir(path)` 校验目标 inode 必须为目录类型，成功后替换 `p->cwd`。

---

## 四、实验步骤

1. 阅读手册实验6：熟悉系统调用全链路与 `ecall`/trapframe/satp 切换概念。
2. 阅读 `usys.S`：理解“a7 放号 + ecall”的桩代码模式。
3. 阅读 `trampoline.S`：重点理解 `uservec` 保存寄存器与切换页表，以及 `userret` 的对称恢复过程。
4. 阅读 `syscall.c`：掌握 syscall 表、参数提取、用户指针校验与分发逻辑。
5. 阅读 `sysproc.c / sysfile.c`：理解典型系统调用实现如何复用 proc/fs 子系统。
6. 编译运行并执行测试：验证 syscall 返回值、错误处理、安全校验与功能正确性。

---

## 五、实验结果与测试

make qemu之后，等待实验5的进程测试运行完之后，输入命令“scalltest”即会运行系统调用测试

![](./实验六截图.png)

---

## 六、实验分析与问题讨论

1. **系统调用层的“最小可信边界”**  
   syscall 层是用户输入进入内核的入口，必须对参数做严谨校验。`syscall.c` 通过 `check_user_range` 把“用户指针合法性”前置，能显著降低深层模块被错误参数冲击的概率。
2. **trampoline 的必要性**  
   切换页表（`satp`）会改变代码/数据的映射。trampoline 通过“内核与用户共同映射同一页”保证切换过程不断电，是用户态/内核态切换的关键工程技巧。
3. **错误处理策略**  
   大多数 syscall 约定失败返回 -1。更细粒度的错误报告可以通过 `errno` 或返回负错误码实现，但会增加 ABI 与用户库复杂度（可作为扩展方向）。
4. **性能成本**  
   系统调用的固定开销来自：Trap 进入/返回、保存/恢复寄存器、页表切换与 TLB 刷新、参数拷贝（copyin/out）。减少不必要的切换、减少拷贝、缩短关键路径是优化方向。
5. **扩展性**  
   本实验的 `syscall_table` + `usys.S` 桩代码模式具备很强的扩展能力：新增 syscall 只需“编号 + 内核实现 + 表项 + 用户桩/用户库封装”。

---

## 七、实验总结与心得体会

实验六让我把“用户态/内核态隔离”真正串成一条可运行的链路：用户通过 `ecall` 进入 trampoline，保存现场并切换到内核页表，随后由 `syscall.c` 统一分发到 `sysproc.c/sysfile.c` 等具体实现，再通过 `userret` 对称恢复回到用户态。特别是用户指针校验与 `copyin/copyout` 的必要性，让我更直观理解了系统调用安全边界的工程意义；而 syscall 表与桩代码的设计，则提供了清晰的扩展接口，为后续实验（文件系统、崩溃恢复、用户程序生态）打下了稳定地基。
