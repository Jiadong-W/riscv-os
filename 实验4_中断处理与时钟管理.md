# 实验四：中断处理与时钟管理

## 一、实验目的

本实验在完成内核启动、输出与内存管理等基础功能后，进一步实现 **RISC-V 中断（Interrupt）/异常（Exception）处理框架** 与 **时钟中断驱动的时间管理**。通过本实验应达到：

1. 理解 RISC-V 特权级（M/S/U）下的 Trap 机制与中断寄存器体系（`stvec/scause/sepc/sstatus/sie/sip` 等）。
2. 完成内核态 Trap 入口（汇编）到 C 语言分发处理的完整链路，并确保上下文保存/恢复正确。
3. 实现时钟中断初始化、周期性触发与“下一次中断编程”，为后续时间片调度/抢占奠定基础。
4. 理解并实现**中断分发、优先级与嵌套**等关键工程问题（至少具备可扩展的接口与基本策略）。

---

## 二、实验原理

### 2.1 中断与异常：统一 Trap 入口 + 原因寄存器分流

RISC-V 将 **中断** 和 **异常** 统一称为 Trap。发生 Trap 时，硬件会：

- 把 Trap 原因写入 `scause`
- 把返回地址写入 `sepc`
- 更新 `sstatus` 的一些位（如 `SPP/SPIE` 等）
- 跳转到 `stvec` 指向的 Trap 入口（本实验为 `kernelvec`）

其中 `scause` 的最高位用于区分中断与异常：

- `scause[63] = 1`：中断（Interrupt）
- `scause[63] = 0`：异常（Exception）
- `scause` 低位字段给出具体原因/中断号（如定时器中断常见编码为 5）

### 2.2 中断寄存器组：使能、挂起、向量与委托

在 S 模式处理中断时，常用 CSR（节选）包括：

- `stvec`：S 模式 Trap 向量基址（本实验设置为 `kernelvec`）
- `sie/sip`：S 模式中断使能/挂起
- `sepc/sstatus/scause/stval`：返回地址、状态、原因与出错地址

由于真实硬件上某些中断源（如定时器）原生属于 M 模式，通常需要通过**委托（delegation）**把中断/异常交给 S 模式处理：

- `mideleg`：中断委托寄存器（Machine → Supervisor）
- `medeleg`：异常委托寄存器（Machine → Supervisor）

本实验在 `start.c` 中将委托打开，并完成定时器相关配置，从而使内核在 S 模式能够直接处理中断。

### 2.3 时钟中断：周期性触发 + “重装载”下一次中断

时钟中断的本质是：当“当前时间 `time`”达到（或超过）“比较寄存器 `stimecmp`”时触发中断。要实现**周期性时钟**，必须在每次中断处理结束前，设置一个新的 `stimecmp`：

- 第一次：启动阶段设置 `stimecmp = time + interval`
- 每次中断：在中断处理函数里再次设置 `stimecmp = now + interval`

从工程角度看，“时钟中断 + ticks 计数 + 唤醒机制”是后续实现 sleep/timeout/抢占调度的基础。

### 2.4 Trap 入口的上下文保存：为什么一定要在汇编做

Trap 发生时，硬件只保证少量 CSR 被写入（`sepc/scause/...`），并不会自动保存通用寄存器。  
因此必须在 Trap 入口（汇编）里保存现场（寄存器），然后才能安全调用 C 函数；处理完成后再恢复寄存器并 `sret` 返回。

---

## 三、实验内容与实现（结合源码分析）

> 说明：本节挑选关键实现进行解释，不在报告中粘贴全部文件。

### 3.1 启动阶段的委托与定时器初始化（start.c）

`start.c` 中 `start()` 负责从 M 模式设置环境并 `mret` 进入 S 模式 `main()`。关键步骤如下（节选）：

```c
void start()
{
  // MPP <- S，mret 后进入 S-mode
  unsigned long x = r_mstatus();
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // mret 返回地址：main()
  w_mepc((uint64)main);

  // 早期关闭分页
  w_satp(0);

  // 委托异常/中断给 S-mode
  w_medeleg(0xffff);
  w_mideleg(0xffff);

  // 使能 S-mode 的外部/时钟中断
  w_sie(r_sie() | SIE_SEIE | SIE_STIE);

  // 配置 PMP：允许 S-mode 访问全部物理内存
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf);

  timerinit();
  asm volatile("mret");
}
```

其中 `timerinit()` 完成定时器与 `stimecmp` 的可用性配置（节选）：

```c
void timerinit()
{
  // 使能 supervisor timer interrupt（通过 mie 的 STIE 位）
  w_mie(r_mie() | MIE_STIE);

  // 使能 sstc 扩展（允许使用 stimecmp）
  w_menvcfg(r_menvcfg() | (1L << 63));

  // 允许 S-mode 访问 time 相关计数器
  w_mcounteren(r_mcounteren() | 2);

  // 设置第一次时钟中断
  w_stimecmp(r_time() + 1000000);
}
```

实现要点与理解：

- **为什么要在 M 模式做这一步？**  
  因为某些平台资源（定时器、PMP、委托寄存器）只能在 M 模式配置；即便后续将中断交给 S 模式处理，也需要先由 M 模式“搭台”。
- **为什么需要周期重装载？**  
  因为 `stimecmp` 是一次性触发条件；若不在中断中重新设置下一次时间点，系统只能触发一次时钟中断。

---

### 3.2 内核态 Trap 入口：kernelvec.S 的保存/恢复策略

本实验的 `kernelvec.S` 采用“**在内核栈上开辟一段空间，保存几乎所有通用寄存器**”的策略（节选）：

```asm
kernelvec:
    addi sp, sp, -256

    sd ra, 0(sp)
    sd gp, 16(sp)
    sd tp, 24(sp)
    sd t0, 32(sp)
    ...
    sd t6, 240(sp)

    call kerneltrap

    ld ra, 0(sp)
    ld gp, 16(sp)
    ...
    ld t6, 240(sp)

    addi sp, sp, 256
    sret
```

关键分析：

1. **为什么要预留 256 字节？**  
   RV64 每个寄存器 8 字节，本实现保存了大部分通用寄存器（不保存 `sp/zero`），256 字节足以覆盖保存区，并且对齐简单。
2. **为什么不保存所有寄存器？**  
   `zero` 恒为 0 无需保存；`sp` 作为保存区基址，改变后再恢复即可（通过 `addi sp, sp, ±256`）。  
   工程上也可以进一步“只保存必要寄存器”来降低开销，但实现复杂度会显著增加。
3. **与 xv6 的典型做法对比**  
   xv6 的 `kernelvec.S` 会更精细地处理 `sscratch`、栈切换与 trapframe（尤其用户态陷入路径）；本实验版本更“直白”，便于先把链路跑通。

---

### 3.3 trap_init：建立 S 模式中断入口与全局使能（trap.c）

`trap_init()` 是中断系统的统一初始化入口（节选）：

```c
void trap_init(void)
{
    w_stvec((uint64)kernelvec);

    // 使能软件/时钟/外部中断
    w_sie(r_sie() | SIE_SSIE | SIE_STIE | SIE_SEIE);

    // 允许用户态读取 cycle/time/instret（便于测试/性能统计）
    w_scounteren(SCOUNTEREN_CY | SCOUNTEREN_TM | SCOUNTEREN_IR);

    initlock(&tickslock, "ticks");
    intr_on();

    // 注册并启用时钟中断（irq=5）
    register_interrupt(5, timer_interrupt_handler);
    enable_interrupt(5);

    uint64 now = get_time();
    sbi_set_timer(now + 1000000); // 约 1ms
}
```

这里的思路是：

- `stvec` 指向汇编入口 `kernelvec`
- `sie` 打开三类中断使能位
- `intr_on()` 打开全局中断（通常对应 `sstatus.SIE`）
- 注册并启用定时器中断处理函数，完成“第一次触发”的编程

---

### 3.4 中断向量表 + 优先级 + 嵌套：可扩展的分发框架

本实验在 `trap.c` 中设计了一个简单的中断框架：

- `interrupt_handlers[64]`：中断向量表（函数指针数组）
- `irq_priorities[64]`：每个 IRQ 的软件优先级
- `nested_level/current_priority`：嵌套层级与当前处理优先级

注册接口：

```c
typedef void (*interrupt_handler_t)(void);
static interrupt_handler_t interrupt_handlers[64] = {0};

void register_interrupt(int irq, interrupt_handler_t handler)
{
    if (irq >= 0 && irq < 64)
        interrupt_handlers[irq] = handler;
}
```

核心分发（支持嵌套与优先级）：

```c
void handle_interrupt_chain(int irq)
{
    if (!interrupt_handlers[irq]) return;

    int irq_priority = get_interrupt_priority(irq);

    // 只有更高优先级的中断才能抢占当前中断
    if (irq_priority <= current_priority && nested_level > 0)
        return;

    int old_priority = current_priority;
    current_priority = irq_priority;
    nested_level++;

    disable_interrupt(irq);  // 防止同源重复进入
    intr_on();               // 允许更高优先级中断嵌套

    interrupt_handlers[irq]();

    intr_off();
    enable_interrupt(irq);

    current_priority = old_priority;
    nested_level--;
}
```

这个设计用很少的代码演示了三个关键工程点：

1. **防重入**：同源中断处理期间先禁用该 IRQ，防止重复进入。
2. **可嵌套**：重新打开全局中断，让更高优先级中断能抢占当前处理流程。
3. **优先级门控**：通过 `current_priority` 阻止“低优先级抢占高优先级”。

---

### 3.5 kerneltrap：区分中断/异常并分派处理

`kerneltrap()` 作为 C 层总入口，从 `kernelvec.S` 被调用（节选）：

```c
void kerneltrap(void) {
    uint64 sepc = r_sepc();
    uint64 sstatus = r_sstatus();
    uint64 scause_val = r_scause();

    if((sstatus & SSTATUS_SPP) == 0)
        panic("kerneltrap: not from supervisor mode");

    if(scause_val & (1ULL << 63)) {
        uint64 irq = scause_val & ~(1ULL << 63);
        if(interrupt_handlers[irq])
            handle_interrupt_chain(irq);
        else
            printf("未知中断: %lu\n", irq);
    } else {
        handle_exception();
    }

    w_sepc(sepc);
    w_sstatus(sstatus);
}
```

要点：

- 通过 `SSTATUS_SPP` 确保 trap 来源是 S 模式（内核态），避免状态混乱。
- `scause` 的最高位用于区分中断/异常；中断再取低位作为 IRQ 编码。
- 处理结束后恢复 `sepc/sstatus`，使 `sret` 能正确返回到被打断位置。

---

### 3.6 时钟中断处理：ticks + 唤醒 + 下一次中断编程

时钟中断处理函数 `timer_interrupt_handler()`（节选）：

```c
volatile uint64 ticks = 0;
struct spinlock tickslock;

void timer_interrupt_handler(void)
{
    acquire(&tickslock);
    ticks++;
    wakeup((void*)&ticks);
    release(&tickslock);

    scheduler_tick();   // 时间片消耗/抢占标记（与后续调度实验衔接）

    // 设置下一次中断
    uint64 now = get_time();
    sbi_set_timer(now + 1000000);

    // 清除挂起位（软件层面清理）
    w_sip(r_sip() & ~(1 << 5));
}
```

工程理解：

- `ticks` 是系统“软件时间基准”，通过自增形成节拍。
- `wakeup(&ticks)` 让“睡眠在 ticks 变量上的线程/进程”被唤醒（典型用于 `sleep(n)`）。
- **必须设置下一次中断**，否则时钟只会触发一次。
- 清除挂起位能避免某些平台/模拟器中重复进入（不同平台实现差异较大，清理策略应结合硬件/固件说明）。

---

### 3.7 用户态陷入路径（补充）：usertrap / usertrapret

虽然本实验重点是“中断与时钟”，但 `trap.c` 同时包含用户态陷入框架（与 xv6 类似）：

- `usertrap()`：处理系统调用、用户态中断与异常（如页故障）
- `usertrapret()`：准备 `trapframe` 并跳转 trampoline 的 `userret`，最终 `sret` 返回用户态

这部分代码与后续“系统调用/进程调度/缺页处理”实验高度耦合，因此提前理解其基本结构有助于后续实验联动调试。

---

## 四、实验步骤

1. 阅读实验四手册：理解中断/异常分类、`stvec/scause/sepc` 作用以及“委托”概念。
2. 阅读 `start.c`：确认 M→S 模式切换过程，重点理解 `timerinit()` 对时钟中断“第一次触发”的配置。
3. 阅读 `kernelvec.S`：确认保存/恢复寄存器集合正确，调用 C 函数前后栈平衡无误。
4. 阅读 `trap.c`：重点关注 `trap_init/kerneltrap/timer_interrupt_handler/handle_interrupt_chain` 的逻辑关系。
5. 编译运行内核，执行时钟中断测试并观察 `ticks/interrupt_count` 等输出变化。

---

## 五、实验结果与测试

make qemu之后自动运行测试函数，输出结果

![](./实验四截图1.png)
![](./实验四截图2.png)
![](./实验四截图3.png)

---

## 六、实验分析与问题讨论

1. **Trap 入口开销**：`kernelvec.S` 保存/恢复大量寄存器（约 256B 的 store/load），是中断路径的主要固定开销之一。进一步优化需要更精细的保存策略或 trapframe 设计，但会提高实现复杂度。
2. **打印会显著放大中断处理时间**：在中断处理函数里大量 `printf` 会导致严重性能下降甚至重入风险（串口输出慢、可能持锁）。实际系统通常只做计数/置标志，把复杂工作交给“下半部/内核线程”。
3. **中断嵌套的边界**：本实现通过“禁用同源 IRQ + 重新打开全局中断”来支持嵌套，但仍需注意：
   - 栈深度随嵌套增加，需评估栈空间与溢出风险；
   - 共享数据必须用锁或原子操作保护；
   - 避免在中断上下文执行可能睡眠的操作。
4. **时钟周期选择的权衡**：1ms 级别的时钟精度对调度和计时友好，但频率越高，系统陷入中断的时间占比越大；实际系统可能采用“tickless + 高精度定时器”减少空转开销。
5. **委托与安全边界**：把中断交给 S 模式处理有利于内核直接管理，但 M 模式仍是固件/平台安全边界；实际硬件上许多资源需通过 SBI/固件接口间接访问。

---

## 七、实验总结与心得体会

通过本实验，我把“中断”从概念层面落到可运行的代码路径上：从 M 模式启动阶段的委托与定时器配置，到 `stvec` 指向的 `kernelvec` 入口保存现场，再到 C 层的 `kerneltrap` 分派与时钟中断“重装载”机制，整个链路形成闭环。同时，本实验的“中断向量表 + 优先级 + 嵌套”框架为后续接入更多中断源（外设、IPI）提供了可扩展接口，也让我更清楚中断处理在性能、可靠性与实时性之间必须做工程权衡。
