# 实验二：内核 printf 与清屏功能实现

## 一、实验目的

1. 理解内核输出系统的分层架构（`printf → uart_putc`）。
2. 掌握 C 语言可变参数机制 `stdarg.h` 的使用方法。
3. 理解数字转字符串算法及不同进制转换原理。
4. 实现支持 `%d`、`%x`、`%p`、`%s`、`%c`、`%%` 的内核 `printf` 函数。
5. 掌握 ANSI 转义序列，实现内核清屏函数 `clear_screen()`。

---

## 二、系统设计

### 2.1 系统架构概述

本实验实现的输出系统采用 **三层架构设计**：

```
┌──────────────────────────────┐
│        格式化输出层           │
│  printf(), printint(), ...   │
├──────────────────────────────┤
│        控制台抽象层           │
│  putc(), printptr()          │
├──────────────────────────────┤
│         硬件驱动层            │
│  uart_putc(), uart_puts()    │
└──────────────────────────────┘
```

- **硬件层**：通过 `uart_putc()` 实现字符发送，是最底层的输出接口。
- **控制台层**：提供对单字符、字符串的封装，形成输出的中间层。
- **格式化层**：负责解析格式化字符串并处理参数，最终输出到 UART。

该设计与 xv6 的 `printf -> consputc -> uartputc` 架构一致，但简化了中间层，直接通过 `putc()` 调用 UART 输出。

---

### 2.2 关键函数设计

#### （1）`putc()`

```c
static void putc(char c) {
    uart_putc(c);
}
```
- 简化版控制台输出函数。
- 直接调用 UART 驱动输出单字符。

#### （2）`printint()`

```c
static void printint(long long xx, int base, int sign);
```

- 将整数转换为字符串输出。
- 支持十进制与十六进制。
- 通过 `%` 和 `/` 实现逐位提取。
- 对负数做符号位处理。

#### （3）`printptr()`

```c
static void printptr(unsigned long long x);
```

- 用于输出指针类型。
- 前缀 `0x`，后接十六进制表示。

#### （4）`printf()`

```c
int printf(const char *fmt, ...);
```

- 核心格式化输出函数。
- 使用 `va_list` 管理可变参数。
- 支持常见格式符：
  - `%d`：十进制整数  
  - `%x`：十六进制整数  
  - `%p`：指针  
  - `%s`：字符串  
  - `%c`：字符  
  - `%%`：输出百分号  

#### （5）`clear_screen()`

```c
void clear_screen(void) {
    uart_puts("\033[2J\033[H");
}
```

- 使用 ANSI 转义序列：
  - `\033[2J`：清屏  
  - `\033[H`：光标回到左上角

---

## 三、与 xv6 的对比分析

| 项目 | xv6 实现 | 本实验实现 |
|------|-----------|-------------|
| 控制台层 | `consputc()` + `uartputc()` | 直接 `putc()` 调用 `uart_putc()` |
| 数字转换 | `printint()` 递归逻辑改为循环 | 使用非递归迭代避免栈溢出 |
| 格式解析 | 支持 `%d/%x/%p/%s/%c` | 保留相同格式集 |
| 指针输出 | 输出固定宽度16进制 | 输出 `0x` + 自适应长度 |
| 清屏功能 | 依赖终端实现（未内置） | 使用 ANSI 转义序列新增 |

---

## 四、实验实现步骤

### 步骤1：分析 xv6 输出模块
- 阅读 `kernel/printf.c` 与 `uart.c`。
- 理解格式化输出如何分层到硬件寄存器输出。

### 步骤2：构建最小输出系统
- 首先实现 `uart_putc()`，验证单字符输出。
- 添加 `putc()` 作为输出封装。

### 步骤3：实现数字转换模块
- 编写 `printint()`，实现进制转换和负数支持。
- 调试输出结果是否正确（42, -1, 0xFF 等）。

### 步骤4：实现格式解析模块
- 实现 `printf()` 主循环，解析 `%` 符号。
- 根据不同格式符调用相应输出函数。

### 步骤5：实现清屏功能
- 参考 ANSI 规范，输出 `\033[2J\033[H`。
- 在 QEMU 控制台中验证效果。

---

## 五、实验结果与测试

### 5.1 基本功能测试

```c
printf("Test integer: %d\n", 123);
printf("Test negative: %d\n", -456);
printf("Test hex: 0x%x\n", 0xABCD);
printf("Test pointer: %p\n", 0x80000000);
printf("Test string: %s\n", "Hello OS");
printf("Test char: %c\n", 'X');
printf("Percent: %%\n");
```

**输出结果：**
```
Test integer: 123
Test negative: -456
Test hex: 0xabcd
Test pointer: 0x80000000
Test string: Hello OS
Test char: X
Percent: %
```

### 5.2 清屏测试

```c
printf("Before clear...\n");
clear_screen();
printf("After clear.\n");
```

**结果：**
屏幕内容被清空，仅显示 `After clear.`。

---

## 六、问题与解决方案

| 问题 | 原因分析 | 解决方案 |
|------|-----------|-----------|
| 负数输出错误 | 没有正确处理补码取负 | 使用 `long long` 并在符号判断后取反 |
| `%s` 输出空指针崩溃 | 未判断 `NULL` | 添加判断 `if (s == 0) s = "(null)"` |
| 十六进制输出逆序 | 需倒序输出缓存 | 通过逆序打印缓冲区 |
| 清屏无效 | ANSI 序列未识别 | 确认 QEMU 控制台支持转义序列 |

---

## 七、结果与总结

本实验成功实现了一个功能完善的 **内核级 printf 系统**，并支持基本格式化输出及清屏操作。  
通过该实验，理解了：

1. **内核输出系统的分层架构设计思想。**
2. **数字到字符串的进制转换算法。**
3. **C 语言可变参数处理机制。**
4. **ANSI 转义序列在控制台中的应用。**

该实现为后续内核模块（如调试输出、日志系统等）提供了基础设施支持。

![运行结果](./image/lab2运行结果.png)

---

## 八、思考题

1. 为什么 `printint()` 采用非递归实现？  
   → 因为递归在内核中会占用额外栈空间，可能导致栈溢出。

2. 如果要实现线程安全的 `printf`，应该如何修改？  
   → 可引入锁机制（如 `spinlock`），防止多核环境下输出交错。

3. 若要支持浮点数格式 `%f`，应如何扩展？  
   → 需实现 `double` 转字符串的算法，可参考 `ftoa()` 实现。

---

**实验者：** *王家栋*  
