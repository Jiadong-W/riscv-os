# 实验一报告：RISC-V 引导与裸机启动

&gt; 基于《实验手册-01》完成最小可运行系统，QEMU 中成功打印 `Hello 05`。

---

## 1 启动流程 QA（任务 1）

| 问题 | 关键结论 | 本实验做法 |
|---|---|---|
| 为何第一条指令设栈？ | `call start` 需保存返回地址 | `la sp, stack_top` 放首行 |
| stack0 在哪？ | xv6 在 `start.c` 定义数组 | 链接脚本 `PROVIDE(stack_top = end + 0x4000)` |
| 栈多大？ | 与中断深度/线程数相关 | 单核 16 KiB 已冗余 |
| 为何清零 BSS？ | C 标准要求未初始化全局变量为 0 | 8 字节循环 `sd zero, 0(t0)` |
| 如何跳转到 C？ | `call symbol` 伪指令 | `call start` 实际编码 `jal ra, start` |

---

## 2 内存布局（任务 2）

| 段   | 起始地址   | 大小示例 | 内容说明         |
| ---- | ---------- | -------- | ---------------- |
| .text | 0x8000_0000 | 64 KiB   | 代码与只读数据   |
| .data | 0x8001_0000 | 16 KiB   | 已初始化全局变量 |
| .bss  | 0x8001_4000 | 16 KiB   | 未初始化全局变量 |
| 栈顶 | 0x8001_8000 | 16 KiB↓  | 向下增长         |

- 起始地址由 QEMU `-kernel` 规定（0x8000_0000）
- 段按 16 KiB 对齐，便于后续页表映射（实验二复用）

---

## 3 最小硬件初始化步骤
1. 设栈指针  
2. 清零 BSS  
3. 初始化 UART  
4. 跳 C → `uart_puts("Hello 05")`

单核场景省略 CLINT/PLIC/页表/多核栈

---

## 4 UART 输出原理（任务 5）
| 寄存器 | 地址 | 描述 |
|---|---|---|
| THR | 0x1000_0000 | 发送保持 |
| LSR | 0x1000_0005 | bit5=1 可发 |

本实验：轮询 THRE，关闭 FIFO/中断，默认波特率 38400 8-N-1

---

## 5 调试技巧与常见问题

| 现象 | 排查要点 |
|---|---|
| 无输出 | `readelf -h kernel.elf` 确认入口地址为 0x8000_0000；GDB `b _entry` 单步 |
| 乱码/丢字符 | 检查轮询 `LSR_TX_IDLE` 是否等待完成 |
| 系统重启循环 | C 主函数末尾未进入死循环，补 `wfi` |

**GDB 启动命令**  
```bash
qemu-system-riscv64 -machine virt -bios none -kernel kernel.elf -nographic -S -gdb tcp::1234
# 另开终端
gdb-multiarch kernel.elf -ex "target remote :1234" -ex "b _entry" -ex "layout asm"
```

---

## 6 思考题摘要

1. **栈大小确定**  
   当前仅 3 层调用深度 + 32 B 局部变量，16 KiB 冗余 90%；后续中断/printf 再扩展。

2. **不清零 BSS 的后果**  
   全局变量初值随机，导致 `if (flag)` 等逻辑不可预测；裸机无 OS 帮忙，必须手动清零。

3. **与 xv6 对比的简化项**  
   | 模块 | xv6 | 本实验 |
   |---|---|---|
   | 多核栈 | 8×4 KiB | 单核 16 KiB |
   | 页表 | Sv39 已启用 | 无分页 |
   | UART | 中断 + 锁 | 轮询，无锁 |
   | 启动文件 | 处理浮点/线程 | 仅设栈、清 BSS |

4. **UART 初始化失败策略**  
   最小系统无日志设备，可在 `uartinit` 失败后死循环并输出魔数，用 GDB 查看 PC 定位。

---

## 7 实验结果
```text
$ make qemu
Hello OS
```
![](屏幕截图 2025-09-27 231356.png)