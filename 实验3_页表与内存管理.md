# 实验三：页表与内存管理

## 一、实验目的

本实验围绕“内核启用虚拟内存”与“物理内存管理”两条主线展开，目标是：

1. 理解 RISC-V Sv39 三级页表的地址转换流程（VA→PA）、页表项（PTE）格式与权限位含义。
2. 实现并验证一个可用的物理页分配器（以页为粒度），支持分配/释放、连续页分配与引用计数。
3. 完成页表管理核心接口（创建/销毁页表、建立映射、区域映射），并在启动阶段构造内核页表并写入 `satp` 以启用分页。
4. 通过输出与调试接口（如页表 dump、内存统计）验证映射关系与权限设置的正确性，为后续“进程/系统调用/文件系统”等实验打基础。

---

## 二、实验原理

### 2.1 RISC-V Sv39：三级页表与虚拟地址结构

Sv39 使用三级页表（L2→L1→L0），每级索引 9 bit，页内偏移 12 bit。虚拟地址（VA）可视为：

- `VPN[2]`：L2 索引（9 bit）
- `VPN[1]`：L1 索引（9 bit）
- `VPN[0]`：L0 索引（9 bit）
- `offset`：页内偏移（12 bit，页大小 4KB）

因此单页映射粒度为 4KB，页表项中保存物理页号（PPN）与权限位（R/W/X/U 等）。

### 2.2 页表项（PTE）与地址转换关键宏

在本项目中，`riscv.h` 给出了核心宏（节选）：

- `PTE_V/R/W/X/U`：有效/读/写/执行/用户可访问
- `PA2PTE`、`PTE2PA`：物理地址与 PTE 中 PPN 字段互转
- `PX(level, va)`：从虚拟地址中提取各级页表索引
- `MAKE_SATP(pagetable)`：构造 satp 值并选择 Sv39 模式
- `sfence_vma()`：刷新 TLB（页表变更后必须同步）

这些宏把“位运算细节”封装起来，让页表代码能更关注逻辑层面的正确性。

### 2.3 为什么启用分页需要写 satp + 刷新 TLB

RISC-V 在启用分页（写 `satp`）后，硬件会通过页表完成地址翻译；而 TLB 会缓存最近的转换结果。  
因此：

- 写 `satp` 切换页表根地址后，需要执行 `sfence.vma` 使旧 TLB 条目失效；
- 在修改页表映射（尤其是权限位/物理页号变化）后，也应在合适时机刷新或局部刷新 TLB。

### 2.4 物理内存分配：位示图 + 引用计数的基本思想

本实验的物理内存管理器以“页”为单位管理内存，通过两组元数据实现：

1. **位示图 bitmap**：每一位对应一个物理页，0 表示空闲，1 表示已分配；
2. **引用计数 refcount**：记录该页被引用的次数（便于共享页、写时复制等高级特性）。

位示图方案结构简单、易于做一致性校验（如 double-free 检测），但寻找空闲页通常需要扫描，性能上属于“用简单换时间”。

---

## 三、实验内容与实现（结合源码分析）

> 说明：本节重点挑选最核心的实现逻辑进行解释，不在报告中粘贴全部文件。

### 3.1 物理内存管理器 kalloc.c：位示图、引用计数与连续页分配

#### (1) 核心数据结构与索引映射

`kalloc.c` 用 `NPAGES = (PHYSTOP - KERNBASE) / PGSIZE` 计算可管理的页总数，并维护：

- `bitmap[BITMAP_WORDS]`：位示图
- `refcount[NPAGES]`：每页引用计数
- `free_pages_count`：空闲页计数（用于快速判断“是否还有内存”）

并通过 `page_index()` / `index_to_page()` 在“页地址”和“下标”之间转换，保证元数据与页内容解耦：

```c
static inline int page_index(void *page) {
    return ((char*)page - (char*)KERNBASE) / PGSIZE;
}
static inline void* index_to_page(int index) {
    return (char*)KERNBASE + index * PGSIZE;
}
```

#### (2) 初始化 pmm_init：标记不可分配区域，计算空闲页数

`pmm_init()` 的关键点不是“把所有页都设为空闲”，而是**精确地把不可分配的区域先标记为已分配**，避免后续错误分配：

1. 先计算位示图自身需要占用的内存区间 `[bitmap_start, bitmap_end)`，并把这些页标记为已分配；
2. 再把内核映像占用区间（从 `KERNBASE` 到 `end`）标记为已分配；
3. 最后遍历位示图统计空闲页数 `free_pages_count`。

这种初始化思路的本质是：**内核自身 + 元数据页必须先“占坑”**，其余才允许加入空闲池。

#### (3) 单页分配 alloc_page：扫描空闲位 + 清零页内容

`alloc_page()` 的主要流程：

1. 若 `free_pages_count <= 0`，直接失败返回；
2. `find_first_free_page()` 扫描位示图找到首个空闲页下标；
3. 将位示图置 1、引用计数设为 1、空闲页计数减 1；
4. 返回该页地址，并执行 `memset(page, 0, PGSIZE)` 清零，避免信息泄漏。

清零页面属于安全加固：即使之后把该页映射到用户态，也不会泄漏旧数据。

#### (4) 单页释放 free_page：地址合法性校验 + double-free 防护 + 引用计数

`free_page()` 的防御性编程较完整：

- **地址合法性**：检查页对齐、范围在 `[KERNBASE, PHYSTOP)` 内，否则 panic；
- **double-free**：若位示图显示该页本来就是空闲（bit 为 0），说明释放重复，直接 panic；
- **引用计数**：先 `refcount--`，只有当计数降到 0 时才真正把位清 0 并增加空闲页数。

这为“共享页/写时复制”提供了基础：一个物理页可被多个映射引用，只有最后一个引用释放时才回收。

#### (5) 连续页分配 alloc_pages：为后续需求预留能力

`alloc_pages(n)` 通过 `find_contiguous_free_pages(n)` 找到连续空闲页区间，然后逐页设置位示图与引用计数。  
相比单页分配，连续页分配对后续模块很有价值，例如：

- 为设备 DMA 或大块连续缓冲区提供条件
- 为大页映射（huge page）或线性映射优化提供实验基础

---

### 3.2 页表管理 vm.c：walk / map / 内核页表构造与启用

#### (1) 创建/销毁页表：create_pagetable / destroy_pagetable

页表本质上也是“页对齐的内存页”，因此页表页本身通过 `alloc_page()` 获得，并清零初始化：

- 创建：分配一页作为根页表（L2），清零后返回。
- 销毁：需要递归回收所有中间级页表页（典型做法为 `freewalk()`），最后释放根页表页。

这种递归释放的关键是：**只释放页表页本身，不释放叶子页指向的数据页**（数据页的生命周期由更高层管理）。

#### (2) 三级遍历 walk_create / walk_lookup：从“索引提取”到“按需创建”

`walk_create(pt, va)` 是实验三最核心的函数之一。它从 L2 到 L1 再到 L0：

- 若中间级页表存在（`PTE_V=1`），则进入下一级；
- 若不存在，则分配新页表页、清零、并把父级 PTE 设置为“指向新页表 + PTE_V”。

最终返回叶子级（L0）对应的 PTE 指针，供建立映射使用。

相对地，`walk_lookup()` 不会创建中间页表：遇到缺失直接返回 0，适用于“查询映射是否存在”。

#### (3) 单页映射 map_page：对齐、重映射检查与权限位设置

`map_page(pt, va, pa, perm)` 体现了“页表正确性”的三条底线：

1. **地址必须页对齐**（VA/PA 均对齐到 4KB）；
2. **禁止重复映射**（若叶子 PTE 已 `PTE_V`，直接 panic）；
3. **PTE 格式正确**：`*pte = PA2PTE(pa) | perm | PTE_V`。

权限位由 `perm` 决定，例如：

- 内核代码段：`PTE_R | PTE_X`
- 内核数据段：`PTE_R | PTE_W`
- 设备 MMIO：`PTE_R | PTE_W`

#### (4) 区域映射 map_region：把“一个区间”拆成“多次 map_page”

内核映射一般是“按段映射”，而页表接口是“按页映射”，因此需要循环建立映射：

- 起始地址向下对齐；
- 按页递增；
- 逐页调用 `map_page`。

这也是为什么“正确的对齐宏”与“正确的大小计算”特别重要：任何 off-by-one 都可能造成遗漏或越界映射。

#### (5) 内核页表创建 kvminit：代码段/数据段/设备/ trampoline 的映射策略

`kvminit()` 体现了一个最小可用内核地址空间需要的映射集合：

1. 创建 `kernel_pagetable`；
2. 映射内核代码段（R+X），范围大致为 `[KERNBASE, etext)`；
3. 映射内核数据段（R+W），范围为 `[etext, PHYSTOP)`；
4. 映射 UART、virtio 等设备页（MMIO，R+W）；
5. 映射 trampoline（R+X），用于后续陷入/返回等代码段支持。

这种映射把“可执行代码”与“可写数据”分离，是内核 W^X（Write XOR Execute）安全设计的基础。

#### (6) 启用虚拟内存 kvminithart：写 satp + sfence.vma

`kvminithart()` 将 `kernel_pagetable` 写入 `satp` 并刷新 TLB：

- `w_satp(MAKE_SATP(kernel_pagetable))`
- `sfence_vma()`

完成后，CPU 将开始按 Sv39 页表进行地址转换，内核进入“真正的虚拟内存模式”。

---

### 3.3 进阶：copyin/copyout 与写时复制（COW）支持

`vm.c` 中包含了更贴近“真实 OS”的用户内存工具链：

- `copyin/copyout`：在用户页表上进行地址翻译并安全拷贝，避免直接解引用用户指针导致内核崩溃；
- `uvmcopy`、`cow_resolve` 等：用于支持 fork 语义下的写时复制（COW），通过 `PTE_COW` 标志与 `refcount` 协同实现共享页与按需复制。

即使本实验阶段未完整跑通进程/系统调用，提前把这些基础设施搭好，能显著降低后续实验的耦合与返工。

---

## 四、实验步骤

1. 阅读手册中“实验三：页表与内存管理”相关内容，理解 Sv39 地址结构与页表项格式。
2. 阅读并梳理 `kalloc.c`，重点关注：`pmm_init`、`alloc_page/free_page`、位示图与引用计数。
3. 阅读并梳理 `vm.c`，重点关注：`walk_create/walk_lookup`、`map_page/map_region`、`kvminit/kvminithart`。
4. 编译并运行内核，确认启用虚拟内存后内核仍可正常输出（UART/console 不应受影响）。
5. 按实验手册或自定义测试点，验证：
   - 分配/释放是否正确（空闲页数变化、double-free 检测）
   - 页表映射是否正确（dump 输出、权限位检查）
   - 启用分页后地址访问是否稳定（无异常/死机）

---

## 五、实验结果与测试

make qemu之后自动运行测试函数，输出结果

![](./实验三截图.png)

---

## 六、实验分析与问题讨论

1. **位示图方案的权衡**：实现简单、可做一致性校验（double-free）、支持连续页，但扫描寻找空闲页可能成为瓶颈。
2. **引用计数的意义**：为共享页/COW 提供基础，同时也要求释放逻辑更谨慎（只有 refcount=0 才能回收）。
3. **页表创建失败的资源回收**：`walk_create()` 在中间级创建失败时需要考虑回滚，否则可能泄漏已分配的中间页表页。当前实现偏“简化”，可作为改进方向。
4. **权限位与安全性**：内核段映射应遵守 W^X，设备页只给 R/W，用户页映射必须严格控制 `PTE_U` 与读写执行权限，避免越权访问。
5. **TLB 同步**：启用分页或修改映射后需要刷新 TLB，否则可能出现“页表已变更但硬件仍用旧缓存”的隐蔽错误。

---

## 七、实验总结与心得体会

实验三把“内存”从抽象概念落到了可运行的代码上：物理页分配器解决“页从哪里来”，页表系统解决“页如何被解释成地址空间”。通过阅读并实现 `pmm_init/alloc_page/free_page` 与 `walk_create/map_page/kvminit/kvminithart`，我对 Sv39 地址翻译的每一步（索引提取、PTE 跳转、权限校验、TLB 同步）有了更细粒度的理解，也明确了后续实验中用户态访问、系统调用参数拷贝、fork 与 COW 等机制的地基在哪里。
