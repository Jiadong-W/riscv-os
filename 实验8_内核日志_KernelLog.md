# 实验八：内核日志（Kernel Log）

## 一、实验目的

本实验实现一个轻量、线程安全、可分级控制的**内核日志系统（Kernel Log）**，用于记录系统运行中的关键信息、警告与错误，辅助调试与监控。目标包括：

1. 设计并实现固定容量的**环形缓冲区**，用于保存最近的日志历史，自动覆盖旧日志，避免内存无限增长。
2. 实现日志分级：`ERROR / WARN / INFO / DEBUG`，并支持**记录阈值**与**控制台阈值**两套过滤策略。
3. 实现线程安全写入：使用**自旋锁**保证并发写入的原子性（设计上兼容多核，即便实验环境可能为单核）。
4. 实现轻量格式化输出：提供 `klog_vsnprintf`（支持 `%d/%x/%s/%p` 等常用格式），将日志预格式化后写入缓冲区。
5. 实现日志转储：`klog_dump()` 打印环形缓冲区内的历史日志，便于定位问题。

> 说明：本报告按“加强版”要求编写：去掉“实验环境”章节，增加源码级分析，并保留测试截图占位。

---

## 二、实验原理

### 2.1 为什么内核需要日志系统

内核调试不同于用户程序：很多错误发生时已经无法依赖用户态工具（gdb/printf 到文件等），并且错误可能与中断、调度、锁竞争等强相关。一个可靠的内核日志系统应当：

- **轻量**：不能显著拖慢关键路径（例如中断/调度）。
- **安全**：多线程/多核并发写入不会破坏日志结构。
- **可控**：支持分级与阈值，避免无关信息刷屏或挤占日志空间。
- **可追溯**：每条日志带时间戳（ticks），便于还原事件顺序。

### 2.2 环形缓冲区（Ring Buffer）

固定容量 `KLOG_CAPACITY` 的数组保存日志条目，配合：

- `head`：指向下一条写入位置（循环递增取模）
- `count`：当前有效条目数量（不超过容量）

写入时：

- `entries[head] = new_entry`
- `head = (head + 1) % KLOG_CAPACITY`
- `count = min(count+1, KLOG_CAPACITY)`

当缓冲区写满后会覆盖最旧的日志，从而保证空间恒定。

### 2.3 分级与双阈值（record_threshold / console_threshold）

本实现将级别定义为枚举（数值越小越“严重”）：

- `ERROR(0)` 最严重
- `WARN(1)`
- `INFO(2)`
- `DEBUG(3)` 最“啰嗦”

两套阈值含义：

- `record_threshold`：低于（更严重或同等）该阈值的日志才**写入环形缓冲**
- `console_threshold`：低于（更严重或同等）该阈值的日志会**立即 printf 输出到控制台**

这样既能保留历史（记录阈值），又能控制实时刷屏（控制台阈值）。

### 2.4 线程安全：自旋锁保护关键区

日志写入需要更新共享状态：`entries/head/count` 等。为避免并发写入导致的交错覆盖、head 错乱、count 失真，本实现使用 `spinlock`：

- 进入临界区：`acquire(&klog.lock)`
- 写入条目 + 更新 head/count
- 退出临界区：`release(&klog.lock)`

> 注意：在真实系统中，日志系统常被用于“锁相关调试”。因此“在持锁期间调用 printf”可能带来复杂的锁依赖问题。本实验选择在锁内格式化与写入，并在满足控制台阈值时同步 printf（简化实现），但要意识到其工程风险与性能代价。

---

## 三、实验内容与实现（结合源码分析）

本实验涉及文件：

- `include/klog.h`
- `kernel/sys/klog.c`

下面结合代码说明核心数据结构与关键函数。

---

### 3.1 数据结构设计（klog.c / klog.h）

#### (1) 日志级别：`klog_level_t`

在 `klog.h` 中定义了日志级别枚举（节选）：

```c
typedef enum {
  KLOG_LEVEL_ERROR = 0,
  KLOG_LEVEL_WARN  = 1,
  KLOG_LEVEL_INFO  = 2,
  KLOG_LEVEL_DEBUG = 3,
} klog_level_t;
```

实现上依赖“数值越小越严重”的顺序，这让阈值比较可以用简单的 `if (level > threshold) return;` 来完成过滤。

#### (2) 日志条目：`klog_entry_t`

`klog.c` 内定义条目格式：

```c
typedef struct {
  uint64 timestamp;            // ticks 时间戳
  klog_level_t level;          // 级别
  char message[KLOG_LINE_MAX]; // 预格式化文本
} klog_entry_t;
```

关键点：

- **预格式化**：写入时把可变参数格式化为字符串存入 entry，dump 时无需再次格式化，逻辑更简单。
- `KLOG_LINE_MAX` 限制单条日志长度，避免 printf 风格字符串导致的无限输出风险。

#### (3) 全局状态：`klog_state_t`（环形缓冲 + 阈值 + 锁）

```c
typedef struct {
  struct spinlock lock;
  klog_entry_t entries[KLOG_CAPACITY];
  int head;
  int count;
  klog_level_t record_threshold;
  klog_level_t console_threshold;
} klog_state_t;
```

- `head/count` 实现环形队列；
- 两个 threshold 分离实现“记录”和“控制台输出”的不同策略；
- `lock` 保证并发安全。

---

### 3.2 初始化：`klog_init()`

`klog_init()` 完成：

1. 初始化自旋锁（如 `initlock(&klog.lock, "klog")`）
2. 清空 head/count
3. 设置默认阈值（例如记录 INFO 以上、控制台 WARN 以上——具体值以代码为准）

该函数通常在内核启动时调用，确保后续所有模块可以安全使用日志接口。

---

### 3.3 轻量格式化：`klog_vsnprintf()` 与辅助函数

为了避免依赖用户态库或完整的 libc，本实验实现了自己的格式化函数：

- `klog_buf_putc(dst, c)`：向输出缓冲写入单字符（带容量边界检查）
- `klog_write_unsigned(dst, x, base)`：把无符号数按 base(10/16) 写成字符串
- `klog_vsnprintf(out, out_sz, fmt, ap)`：解析 fmt，支持若干常用占位符

实现思路（概念）：

1. 扫描格式串 `fmt`：
   - 普通字符直接写入输出缓冲
   - 遇到 `%` 进入占位符解析
2. 对 `%d/%u/%x/%p/%s/%c` 读取对应类型参数
3. 写入输出缓冲，保证不越界并以 `\0` 结尾

这种“子集 printf”满足内核日志的核心需求：**够用 + 可控 + 不依赖复杂库**。

---

### 3.4 日志写入：`klog_log(level, fmt, ...)`

日志写入按你提供的设计描述与源码实现可总结为 5 步：

1. **阈值过滤（记录阈值）**  
   若 `level` 不满足 `record_threshold`，直接返回，避免额外开销。
2. **格式化**  
   使用 `klog_vsnprintf` 将变参格式化到临时 buffer（或直接写入 entry.message）。
3. **加锁并写入环形缓冲区**  
   更新 `entries[head]`、推进 `head`、维护 `count`，保证并发安全。
4. **控制台输出（控制台阈值）**  
   若 `level` 满足 `console_threshold`，立即调用 `printf` 输出（实时可见）。
5. **释放锁**

工程理解：

- 把阈值过滤放在最前，能显著减少 DEBUG 级日志对系统的影响；
- “记录阈值”和“控制台阈值”分离使调试更灵活：可以记录很多，但只打印少数。

---

### 3.5 日志转储：`klog_dump()`

`klog_dump()` 遍历环形缓冲区打印历史日志。典型输出包含：

- 时间戳（ticks）
- 级别字符串
- message

实现注意点：

- 需要加锁保护遍历期间 entries/head/count 的一致性；
- 遍历顺序应从“最旧条目”到“最新条目”，否则会影响排查问题时的时间线理解。

---

## 四、实验步骤

1. 阅读实验说明，确定设计需求：环形缓冲、分级阈值、线程安全、格式化与 dump。
2. 实现 `klog.h`：定义 `klog_level_t`、对外 API 声明。
3. 实现 `klog.c`：
   - 数据结构 `klog_entry_t / klog_state_t`
   - 初始化 `klog_init`
   - 格式化 `klog_vsnprintf`（及辅助函数）
   - 写入 `klog_log`（阈值过滤 + 加锁写入 + 可选 printf）
   - 转储 `klog_dump`
4. 将日志系统接入内核关键路径（例如：进程创建、系统调用错误、文件系统事务提交、panic 前输出等）。
5. 编译运行并执行测试用例（见下一节），补充截图。

---

## 五、实验结果与测试

make qemu之后，等待实验5的进程测试运行完之后，输入命令“klogtest”即会运行内核日志测试

![](./实验八截图1.png)
![](./实验八截图2.png)

---

## 六、实验分析与问题讨论

1. **在锁内 printf 的风险**  
   `printf` 可能内部获取锁或引发较长时间占用，若日志系统也被用于锁相关调试，可能造成锁顺序复杂化。更工程化的做法是：锁内只写环形缓冲；控制台输出交给异步线程/下半部处理。
2. **格式化子集的取舍**  
   只支持常用格式（`%d/%x/%s/%p`）能大幅降低复杂度与代码体积；缺点是功能受限。教学实验中“够用优先”是合理权衡。
3. **时间戳 ticks 的精度**  
   ticks 依赖时钟中断，精度受 tick 周期影响（例如 1ms/10ms）。优点是简单稳定；缺点是无法提供高精度时间（可扩展为读取 `time` CSR 或高精度计时器）。
4. **覆盖策略的可解释性**  
   固定容量覆盖旧日志能保证空间稳定，但如果错误发生很早，旧日志可能被覆盖。可扩展为“关键级别不覆盖”“按级别保留”或“遇到 ERROR 冻结缓冲”。
5. **对系统性能的影响**  
   高吞吐路径中大量 DEBUG 日志会显著影响性能，因此阈值过滤必须尽量前置，并尽量减少临界区长度。

---

## 七、实验总结与心得体会

本实验实现了一个小而实用的内核日志系统：以环形缓冲区保存历史、以自旋锁保证并发安全、以双阈值实现“记录/打印分离”，并通过自定义 `klog_vsnprintf` 在无 libc 环境下提供基本格式化能力。日志系统不仅能帮助定位 bug，也为后续实验（系统调用、文件系统事务、崩溃恢复等）的调试提供了统一的观测入口；同时也让我更清楚“调试工具本身”必须在性能、可靠性与实现复杂度之间做工程权衡。
